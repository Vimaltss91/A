import mysql.connector
from datetime import datetime

def reset_auto_increment_if_needed(cursor):
    cursor.execute("SELECT MAX(s_no) FROM namespace_status")
    max_s_no = cursor.fetchone()[0]

    if max_s_no >= 30:
        cursor.execute("ALTER TABLE namespace_status AUTO_INCREMENT = 1")

def insert_namespace_record(release_tag, namespace, status):
    connection = mysql.connector.connect(
        host="your_mysql_host",
        user="your_mysql_user",
        password="your_mysql_password",
        database="your_database"
    )
    cursor = connection.cursor()

    # Check and reset AUTO_INCREMENT if needed
    reset_auto_increment_if_needed(cursor)

    # Insert the new record
    insert_query = """
        INSERT INTO namespace_status (release_tag, namespace, status, date)
        VALUES (%s, %s, %s, %s)
    """
    current_date = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    cursor.execute(insert_query, (release_tag, namespace, status, current_date))

    # Commit the transaction
    connection.commit()

    # Fetch and print the auto-incremented s_no for the inserted record
    cursor.execute("SELECT LAST_INSERT_ID()")
    s_no = cursor.fetchone()[0]
    print(f"Inserted record with s_no: {s_no}")

    # Close the connection
    cursor.close()
    connection.close()

# Example usage:
release_tag = '24.30.-OCNGF-34343'
namespace = 'devops1'
status = 'Available'

insert_namespace_record(release_tag, namespace, status)


CREATE DATABASE namespace_management;
USE namespace_management;


CREATE TABLE namespace_status (
    s_no INT AUTO_INCREMENT PRIMARY KEY,
    release_tag VARCHAR(255),
    namespace VARCHAR(50),
    status ENUM('Running', 'Blocked', 'Available') DEFAULT 'Available',
    date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_s_no CHECK (s_no BETWEEN 1 AND 30)
);



INSERT INTO namespace_status (release_tag, namespace, status) VALUES
('24.30.-OCNGF-34343', 'devops1', 'Available'),
('24.30.-OCNGF-34343', 'devops2', 'Available'),
('24.30.-OCNGF-34343', 'devops3', 'Available'),
('24.30.-OCNGF-34343', 'devops4', 'Available'),
...
('24.30.-OCNGF-34343', 'devops30', 'Available');


SELECT * FROM namespace_status;


#!/bin/bash

# Prompt the user to enter credentials
read -p "Enter PIP Username: " PIP_USERNAME
read -sp "Enter PIP Password: " PIP_PASSWORD
echo

# URL encode the username and password
PIP_USERNAME_ENCODED=$(python3 -c "import urllib.parse; print(urllib.parse.quote('''$PIP_USERNAME'''))")
PIP_PASSWORD_ENCODED=$(python3 -c "import urllib.parse; print(urllib.parse.quote('''$PIP_PASSWORD'''))")

# Build the Docker image with build arguments
docker build --build-arg PIP_USERNAME=$PIP_USERNAME_ENCODED --build-arg PIP_PASSWORD=$PIP_PASSWORD_ENCODED -t my-python-app .


<html lang="en" ng-app="BuildDeploymentTestApp">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Build, Deployment, Test UI</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
    <script src="app.js"></script>
</head>
<body ng-controller="BuildDeploymentTestController">

    <div class="container">
        <!-- Existing content -->

        <!-- Login Form -->
        <div ng-app="loginApp" ng-controller="loginController">
            <form ng-submit="login()">
                <label for="username">Username:</label>
                <input type="text" id="username" ng-model="username" required>
                
                <label for="password">Password:</label>
                <input type="password" id="password" ng-model="password" required>
                
                <button type="submit">Login</button>
            </form>
        </div>
    </div>
</body>
</html>



------

var app = angular.module('BuildDeploymentTestApp', []);

// Define options for Enable PP Branch
app.controller('BuildDeploymentTestController', function($scope) {
    // Your existing code
});

var loginApp = angular.module('loginApp', []);

loginApp.controller('loginController', function($scope, $http) {
    $scope.login = function() {
        var data = {
            username: $scope.username,
            password: $scope.password
        };

        $http.post('http://localhost:3000/login', data)
        .then(function(response) {
            if (response.data.auth) {
                alert('Login successful');
                // Handle successful login here (e.g., redirect to another page)
            } else {
                alert('Login failed');
            }
        }, function(error) {
            alert('Login failed');
        });
    };
});






-----------


const express = require('express');
const mysql = require('mysql');
const bodyParser = require('body-parser');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

const app = express();
const port = 3000;

app.use(bodyParser.json());

const db = mysql.createConnection({
    host: 'localhost',
    user: 'root',
    password: '',
    database: 'userdb'
});

db.connect(err => {
    if (err) {
        console.error('Database connection failed:', err.stack);
        return;
    }
    console.log('Connected to database.');
});

app.post('/login', (req, res) => {
    const { username, password } = req.body;
    if (!username || !password) {
        return res.status(400).send('Please provide username and password');
    }

    db.query('SELECT * FROM users WHERE username = ?', [username], (err, results) => {
        if (err) throw err;
        if (results.length === 0) {
            return res.status(400).send('User not found');
        }

        const user = results[0];
        const passwordIsValid = bcrypt.compareSync(password, user.password);
        if (!passwordIsValid) {
            return res.status(401).send('Invalid password');
        }

        const token = jwt.sign({ id: user.id }, 'secret-key', {
            expiresIn: 86400 // 24 hours
        });

        res.status(200).send({ auth: true, token });
    });
});

app.post('/register', (req, res) => {
    const { username, password } = req.body;
    if (!username || !password) {
        return res.status(400).send('Please provide username and password');
    }

    const hashedPassword = bcrypt.hashSync(password, 8);

    db.query('INSERT INTO users (username, password) VALUES (?, ?)', [username, hashedPassword], (err, result) => {
        if (err) throw err;
        res.status(201).send('User registered');
    });
});

app.listen(port, () => {
    console.log(`Server running on port ${port}`);
});




import os
import re

def filter_gradle_build(input_file, output_file):
    input_path = os.path.join(os.getenv('CI_PROJECT_DIR'), input_file)
    output_path = os.path.join(os.getenv('CI_PROJECT_DIR'), output_file)

    with open(input_path, 'r') as infile, open(output_path, 'w') as outfile:
        skip_task = False
        task_pattern = re.compile(r'^> Task :(\S+)')
        
        for line in infile:
            task_match = task_pattern.match(line)
            if task_match:
                task_name = task_match.group(1)
                skip_task = 'test' in task_name.lower()
                if not skip_task:
                    # Write the task header
                    outfile.write(line)
                else:
                    # Skip lines until the next task header
                    while True:
                        next_line = next(infile, None)
                        if next_line is None:
                            break
                        next_task_match = task_pattern.match(next_line)
                        if next_task_match:
                            task_name = next_task_match.group(1)
                            skip_task = 'test' in task_name.lower()
                            if not skip_task:
                                outfile.write(next_line)
                                break
                continue
            
            if not skip_task:
                outfile.write(line)

# Usage
filter_gradle_build('gradle_build.txt', 'filtered_gradle_build.txt')



import re

def filter_gradle_build(input_file, output_file):
    with open(input_file, 'r') as infile, open(output_file, 'w') as outfile:
        skip_task = False
        task_pattern = re.compile(r'^> Task :(\S+)')
        
        for line in infile:
            task_match = task_pattern.match(line)
            if task_match:
                task_name = task_match.group(1)
                skip_task = 'test' in task_name.lower()
                if not skip_task:
                    # Write the task header
                    outfile.write(line)
                else:
                    # Skip lines until the next task header
                    while True:
                        next_line = next(infile, None)
                        if next_line is None:
                            break
                        next_task_match = task_pattern.match(next_line)
                        if next_task_match:
                            task_name = next_task_match.group(1)
                            skip_task = 'test' in task_name.lower()
                            if not skip_task:
                                outfile.write(next_line)
                                break
                continue
            
            if not skip_task:
                outfile.write(line)

# Usage
filter_gradle_build('gradle_build.txt', 'filtered_gradle_build.txt')




def parse_repo_counts(file_path):
    # Initialize a dictionary to store the counts
    repo_counts = {}
    repo1_urls = {'3rd_party': [], '4th_party': []}

    # Read the file line by line
    with open(file_path, 'r') as file:
        for line in file:
            parts = line.strip().split()
            if len(parts) < 3:
                continue  # Skip lines that do not have the expected format
            
            url = parts[0]
            nth_party = parts[-2].strip()
            repo_name = parts[-1].strip()
            
            # Map specific repo names to 'opensource'
            if repo_name in ['opensource-release-maven', 'opensource-release-gradle']:
                repo_name = 'opensource'
            
            if nth_party not in repo_counts:
                repo_counts[nth_party] = {}
            
            if repo_name not in repo_counts[nth_party]:
                repo_counts[nth_party][repo_name] = 0
            
            repo_counts[nth_party][repo_name] += 1

            # Collect URLs for 3rd and 4th party from repo1
            if repo_name == 'repo1' and nth_party in ['3rd_party', '4th_party']:
                repo1_urls[nth_party].append(url)

    # Define the headers for the table
    headers = ['nth_party', 'opensource', 'repo1', 'occnp']

    # Prepare the table for output
    table = []
    table.append(headers)

    # Initialize total counts
    total_counts = {header: 0 for header in headers[1:]}

    for nth_party in repo_counts:
        row = [nth_party]
        for header in headers[1:]:
            count = repo_counts[nth_party].get(header, 0)
            row.append(count)
            total_counts[header] += count
        table.append(row)

    # Add a separator row
    table.append(['-' * 10] * len(headers))

    # Add the total row
    total_row = ['Total']
    for header in headers[1:]:
        total_row.append(total_counts[header])
    table.append(total_row)

    return table, repo1_urls

# Usage
file_path = 'final_list.txt'
table, repo1_urls = parse_repo_counts(file_path)

# Print the table
for row in table:
    print("{:<10} {:<10} {:<10} {:<10}".format(*row))

# Print the URLs for 3rd and 4th party from repo1
print("\nURLs for 3rd party from repo1:")
for url in repo1_urls['3rd_party']:
    print(url)

print("\nURLs for 4th party from repo1:")
for url in repo1_urls['4th_party']:
    print(url)


def parse_repo_counts(file_path):
    # Initialize a dictionary to store the counts
    repo_counts = {}

    # Read the file line by line
    with open(file_path, 'r') as file:
        for line in file:
            parts = line.strip().split()
            if len(parts) < 3:
                continue  # Skip lines that do not have the expected format
            
            nth_party = parts[-2].strip()
            repo_name = parts[-1].strip()
            
            # Map specific repo names to 'opensource'
            if repo_name in ['opensource-release-maven', 'opensource-release-gradle']:
                repo_name = 'opensource'
            
            if nth_party not in repo_counts:
                repo_counts[nth_party] = {}
            
            if repo_name not in repo_counts[nth_party]:
                repo_counts[nth_party][repo_name] = 0
            
            repo_counts[nth_party][repo_name] += 1

    # Define the headers for the table
    headers = ['nth_party', 'opensource', 'repo1', 'occnp']

    # Prepare the table for output
    table = []
    table.append(headers)

    # Initialize total counts
    total_counts = {header: 0 for header in headers[1:]}

    for nth_party in repo_counts:
        row = [nth_party]
        for header in headers[1:]:
            count = repo_counts[nth_party].get(header, 0)
            row.append(count)
            total_counts[header] += count
        table.append(row)

    # Add a separator row
    table.append(['-' * 10] * len(headers))

    # Add the total row
    total_row = ['Total']
    for header in headers[1:]:
        total_row.append(total_counts[header])
    table.append(total_row)

    return table

# Usage
file_path = 'final_list.txt'
table = parse_repo_counts(file_path)

# Print the table
for row in table:
    print("{:<10} {:<10} {:<10} {:<10}".format(*row))


def parse_repo_counts(file_path):
    # Initialize a dictionary to store the counts
    repo_counts = {}

    # Read the file line by line
    with open(file_path, 'r') as file:
        for line in file:
            parts = line.strip().split()
            if len(parts) < 3:
                continue  # Skip lines that do not have the expected format
            
            nth_party = parts[-2].strip()
            repo_name = parts[-1].strip()
            
            # Map specific repo names to 'opensource'
            if repo_name in ['opensource-release-maven', 'opensource-release-gradle']:
                repo_name = 'opensource'
            
            if nth_party not in repo_counts:
                repo_counts[nth_party] = {}
            
            if repo_name not in repo_counts[nth_party]:
                repo_counts[nth_party][repo_name] = 0
            
            repo_counts[nth_party][repo_name] += 1

    # Define the headers for the table
    headers = ['nth_party', 'opensource', 'repo1', 'occnp']

    # Prepare the table for output
    table = []
    table.append(headers)

    # Initialize total counts
    total_counts = {header: 0 for header in headers[1:]}

    for nth_party in repo_counts:
        row = [nth_party]
        for header in headers[1:]:
            count = repo_counts[nth_party].get(header, 0)
            row.append(count)
            total_counts[header] += count
        table.append(row)

    # Add the total row
    total_row = ['Total']
    for header in headers[1:]:
        total_row.append(total_counts[header])
    table.append(total_row)

    return table

# Usage
file_path = 'final_list.txt'
table = parse_repo_counts(file_path)

# Print the table
for row in table:
    print("{:<10} {:<10} {:<10} {:<10}".format(*row))


# Usage
file_path = 'final_list.txt'
table = parse_repo_counts(file_path)

# Print the table
for row in table:
    print("{:<10} {:<10} {:<10} {:<10}".format(*row))


# Usage
file_path = 'final_list.txt'
table = parse_repo_counts(file_path)

# Print the table
for row in table:
    print("{:<10} {:<10} {:<10} {:<10}".format(*row))


def parse_repo_counts(file_path):
    # Initialize a dictionary to store the counts
    repo_counts = {}

    # Read the file line by line
    with open(file_path, 'r') as file:
        for line in file:
            parts = line.strip().split()
            if len(parts) < 3:
                continue  # Skip lines that do not have the expected format
            
            nth_party = parts[-2].strip()
            repo_name = parts[-1].strip()
            
            # Map specific repo names to 'opensource'
            if repo_name in ['opensource-release-maven', 'opensource-release-gradle']:
                repo_name = 'opensource'
            
            if nth_party not in repo_counts:
                repo_counts[nth_party] = {}
            
            if repo_name not in repo_counts[nth_party]:
                repo_counts[nth_party][repo_name] = 0
            
            repo_counts[nth_party][repo_name] += 1

    # Define the headers for the table
    headers = ['nth_party', 'opensource', 'repo1', 'occnp']

    # Prepare the table for output
    table = []
    table.append(headers)
    
    for nth_party in repo_counts:
        row = [nth_party]
        for header in headers[1:]:
            row.append(repo_counts[nth_party].get(header, 0))
        table.append(row)

    return table

# Usage
file_path = 'final_list.txt'
table = parse_repo_counts(file_path)

# Print the table
for row in table:
    print("{:<10} {:<10} {:<10} {:<10}".format(*row))


def parse_repo_counts(file_path):
    # Initialize a dictionary to store the counts
    repo_counts = {}

    # Read the file line by line
    with open(file_path, 'r') as file:
        for line in file:
            parts = line.strip().split()
            if len(parts) < 3:
                continue  # Skip lines that do not have the expected format
            
            nth_party = parts[-2].strip()
            repo_name = parts[-1].strip()
            
            if nth_party not in repo_counts:
                repo_counts[nth_party] = {}
            
            if repo_name not in repo_counts[nth_party]:
                repo_counts[nth_party][repo_name] = 0
            
            repo_counts[nth_party][repo_name] += 1

    # Define the headers for the table
    headers = ['nth_party', 'opensource', 'repo1', 'occnp']

    # Prepare the table for output
    table = []
    table.append(headers)
    
    for nth_party in repo_counts:
        row = [nth_party]
        for header in headers[1:]:
            row.append(repo_counts[nth_party].get(header, 0))
        table.append(row)

    return table

# Usage
file_path = 'final_list.txt'
table = parse_repo_counts(file_path)

# Print the table
for row in table:
    print("{:<10} {:<10} {:<10} {:<10}".format(*row))


def parse_repo_counts(file_path):
    # Initialize a dictionary to store the counts
    repo_counts = {}

    # Read the file line by line
    with open(file_path, 'r') as file:
        for line in file:
            parts = line.strip().split()
            if len(parts) < 3:
                continue  # Skip lines that do not have the expected format
            
            url, nth_party, repo_name = parts[-3], parts[-2], parts[-1]
            
            if nth_party not in repo_counts:
                repo_counts[nth_party] = {}
            
            if repo_name not in repo_counts[nth_party]:
                repo_counts[nth_party][repo_name] = 0
            
            repo_counts[nth_party][repo_name] += 1

    # Define the headers for the table
    headers = ['nth_party', 'opensource', 'repo1', 'occnp']

    # Prepare the table for output
    table = []
    table.append(headers)
    
    for nth_party in repo_counts:
        row = [nth_party]
        for header in headers[1:]:
            row.append(repo_counts[nth_party].get(header, 0))
        table.append(row)

    return table

# Usage
file_path = 'final_list.txt'
table = parse_repo_counts(file_path)

# Print the table
for row in table:
    print("{:<10} {:<10} {:<10} {:<10}".format(*row))




{
  "name": "your-project-name",
  "version": "1.0.0",
  "description": "Your project description",
  "main": "index.js",
  "scripts": {
    "preinstall": "node log-fetch.js"
  },
  "author": "Your Name",
  "license": "ISC",
  "dependencies": {
    "some-package": "^1.0.0"
  }
}


"scripts": {
  "preinstall": "node log-fetch.js"
}


const https = require('https');

const originalRequest = https.request;
https.request = function(options, callback) {
  console.log('Fetching from:', options.hostname);
  return originalRequest.apply(this, arguments);
};

console.log('Preinstall hook executed');



kube_pod_container_status_terminated_reason{namespace="my-namespace", reason="Evicted"}


kube_pod_container_status_terminated_reason{namespace="my-namespace"}


100 * (node_filesystem_size_bytes{fstype=~"ext4|xfs", instance="node1.example.com"} - node_filesystem_free_bytes{fstype=~"ext4|xfs", instance="node1.example.com"}) / node_filesystem_size_bytes{fstype=~"ext4|xfs", instance="node1.example.com"}

(node_filesystem_size_bytes - node_filesystem_free_bytes) / node_filesystem_size_bytes * 100


// Initialize counters for each repository
def mavenCount = 0
def gradleCount = 0
def repo1Count = 0

configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details ->
        // Extract the module identifier (group and name)
        def moduleIdentifier = "${details.requested.group}:${details.requested.name}"

        // Check which repository the dependency belongs to based on the module identifier
        if (moduleIdentifier.startsWith('opensource-release-maven')) {
            mavenCount++
        } else if (moduleIdentifier.startsWith('opensource-release-gradle')) {
            gradleCount++
        } else if (moduleIdentifier.startsWith('repo1')) {
            repo1Count++
        }
    }
}

gradle.buildFinished {
    // Print the counts for each repository
    logger.lifecycle("Resolved ${mavenCount} dependencies from opensource-release-maven")
    logger.lifecycle("Resolved ${gradleCount} dependencies from opensource-release-gradle")
    logger.lifecycle("Resolved ${repo1Count} dependencies from repo1")
}


// Initialize counters for each repository
def mavenCount = 0
def gradleCount = 0
def repo1Count = 0

configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details ->
        // Extract the repository URL from which the dependency is resolved
        def repositoryUrl = details.getRequested().getRepoUrl()

        // Determine the repository based on the repository URL
        if (repositoryUrl == 'https://example.com/opensource-release-maven') {
            mavenCount++
        } else if (repositoryUrl == 'https://example.com/opensource-release-gradle') {
            gradleCount++
        } else if (repositoryUrl == 'https://example.com/repo1') {
            repo1Count++
        }
    }
}

gradle.buildFinished {
    // Print the counts for each repository
    logger.lifecycle("Resolved ${mavenCount} dependencies from opensource-release-maven")
    logger.lifecycle("Resolved ${gradleCount} dependencies from opensource-release-gradle")
    logger.lifecycle("Resolved ${repo1Count} dependencies from repo1")
}


// Initialize counters for each repository
def mavenCount = 0
def gradleCount = 0
def repo1Count = 0

configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details ->
        // Extract the module identifier
        def moduleIdentifier = details.requested

        // Determine the repository based on module identifier group
        if (moduleIdentifier.group == 'opensource-release-maven') {
            mavenCount++
        } else if (moduleIdentifier.group == 'opensource-release-gradle') {
            gradleCount++
        } else if (moduleIdentifier.group == 'repo1') {
            repo1Count++
        }
    }
}

gradle.buildFinished {
    // Print the counts for each repository
    logger.lifecycle("Resolved ${mavenCount} dependencies from opensource-release-maven")
    logger.lifecycle("Resolved ${gradleCount} dependencies from opensource-release-gradle")
    logger.lifecycle("Resolved ${repo1Count} dependencies from repo1")
}



// Initialize counters for each repository
def mavenCount = 0
def gradleCount = 0
def repo1Count = 0

configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details ->
        // Extract the repository name
        def repository = details.resolvedArtifactRepository?.name ?: "unknown"

        // Increment the respective counter based on the repository name
        switch (repository) {
            case "opensource-release-maven":
                mavenCount++
                break
            case "opensource-release-gradle":
                gradleCount++
                break
            case "repo1":
                repo1Count++
                break
            // Add more cases if needed for additional repositories
        }
    }
}

gradle.buildFinished {
    // Print the counts for each repository
    logger.lifecycle("Resolved ${mavenCount} dependencies from opensource-release-maven")
    logger.lifecycle("Resolved ${gradleCount} dependencies from opensource-release-gradle")
    logger.lifecycle("Resolved ${repo1Count} dependencies from repo1")
}


def repositoryCount = [:]

configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details ->
        def resolvedFrom = details.getRequested().getGroup()
        if (repositoryCount.containsKey(resolvedFrom)) {
            repositoryCount[resolvedFrom] += 1
        } else {
            repositoryCount[resolvedFrom] = 1
        }
    }
}

gradle.buildFinished {
    repositoryCount.each { repo, count ->
        logger.lifecycle("Resolved ${count} dependencies from repository ${repo}")
    }
}


configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details ->
        // Get the module identifier
        def moduleIdentifier = details.requested

        // Get the repository URLs from where the dependency is resolved
        def repositoryUrls = details.getAllCandidatePatterns().collect { pattern ->
            details.getFrom().findAll { pattern.isMatching(it) }.collect { it }
        }.flatten().collect { it.toString() }.unique()

        // Log the resolution information
        repositoryUrls.each { repositoryUrl ->
            logger.lifecycle("Resolved ${moduleIdentifier.group}:${moduleIdentifier.name}:${moduleIdentifier.version} from ${repositoryUrl}")
        }
    }
}


configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details ->
        // Get the repository URL from where the dependency is resolved
        def repository = details.requested.group + ":" + details.requested.name
        def resolvedFrom = details.resolvedArtifactRepository != null ? details.resolvedArtifactRepository.name : "unknown repository"
        logger.lifecycle("Resolved ${repository} from ${resolvedFrom}")
    }
}


configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details ->
        def origin = details.requested
        logger.lifecycle("Resolved ${origin.group}:${origin.name}:${origin.version} from ${details.from}")
    }
}



import org.gradle.api.internal.artifacts.ivyservice.resolveengine.result.ResolvedArtifactResult

task resolveDependencies {
    doLast {
        def repoCounts = [:].withDefault { [url: '', count: 0] }

        repositories.each { repo ->
            if (repo instanceof MavenArtifactRepository) {
                def repoName = repo.name
                def repoUrl = repo.url.toString()
                repoCounts[repoName] = [url: repoUrl, count: 0]
            }
        }

        configurations.compileClasspath.incoming.artifacts.each { artifactResult ->
            if (artifactResult instanceof ResolvedArtifactResult) {
                def repoUrl = artifactResult.resolvedVariant.toString()
                def repoName = 'Other'
                repoCounts.each { name, info ->
                    if (repoUrl.contains(info.url)) {
                        repoName = name
                    }
                }
                repoCounts[repoName].count++
            }
        }

        repoCounts.each { repo, info ->
            println "Dependencies downloaded from ${info.url}: ${info.count}"
        }
    }
}

task buildWithDependencyReport {
    dependsOn 'build', 'resolveDependencies'
}



task resolveDependencies {
    doLast {
        def repoCounts = [:].withDefault { [url: '', count: 0] }

        def repositoryUrls = [
            'https://repo.maven.apache.org/maven2': 'MavenCentral',
            'https://example.com/open-source-release-maven': 'OpenSourceReleaseMaven',
            'https://example.com/open-source-release-gradle': 'OpenSourceReleaseGradle'
        ]

        repositories.each { repo ->
            if (repo instanceof MavenArtifactRepository) {
                def repoName = repo.name
                def repoUrl = repo.url.toString()
                repoCounts[repoName] = [url: repoUrl, count: 0]
            }
        }

        configurations.compileClasspath.incoming.resolutionResult.allDependencies.each { dependency ->
            def selected = dependency.selected
            if (selected != null && selected.id.displayName) {
                def repoName = 'Other'
                repositoryUrls.each { urlFragment, name ->
                    if (selected.id.displayName.contains(urlFragment)) {
                        repoName = name
                    }
                }
                repoCounts[repoName].count++
            }
        }

        repoCounts.each { repo, info ->
            println "Dependencies downloaded from ${info.url}: ${info.count}"
        }
    }
}

task buildWithDependencyReport {
    dependsOn 'build', 'resolveDependencies'
}


task resolveDependencies {
    doLast {
        def repoCounts = [
            'OpenSourceReleaseMaven': 0,
            'OpenSourceReleaseGradle': 0,
            'MavenCentral': 0,
            'Other': 0
        ]

        def repositoryNames = [
            'example.com/open-source-release-maven': 'OpenSourceReleaseMaven',
            'example.com/open-source-release-gradle': 'OpenSourceReleaseGradle',
            'repo.maven.apache.org': 'MavenCentral'
        ]

        configurations.compileClasspath.incoming.resolutionResult.allDependencies.each { dependency ->
            def selected = dependency.selected
            if (selected != null) {
                def repoName = 'Other'
                def componentId = selected.id
                repositoryNames.each { urlFragment, name ->
                    if (componentId.toString().contains(urlFragment)) {
                        repoName = name
                    }
                }
                repoCounts[repoName]++
            }
        }

        repoCounts.each { repo, count ->
            println "Dependencies downloaded from ${repo}: ${count}"
        }
    }
}

task buildWithDependencyReport {
    dependsOn 'build', 'resolveDependencies'
}


task resolveDependencies {
    doLast {
        def repoCounts = [
            'OpenSourceReleaseMaven': 0,
            'OpenSourceReleaseGradle': 0,
            'MavenCentral': 0,
            'Other': 0
        ]

        def repositoryNames = [
            'example.com/open-source-release-maven': 'OpenSourceReleaseMaven',
            'example.com/open-source-release-gradle': 'OpenSourceReleaseGradle',
            'repo.maven.apache.org': 'MavenCentral'
        ]

        configurations.compileClasspath.incoming.resolutionResult.allDependencies.each { dependency ->
            def selected = dependency.selected
            if (selected != null) {
                def repoName = 'Other'
                def componentId = selected.id
                repositoryNames.each { urlFragment, name ->
                    if (componentId.toString().contains(urlFragment)) {
                        repoName = name
                    }
                }
                repoCounts[repoName]++
            }
        }

        repoCounts.each { repo, count ->
            println "Dependencies downloaded from ${repo}: ${count}"
        }
    }
}

task buildWithDependencyReport {
    dependsOn 'build', 'resolveDependencies'
}


import org.gradle.api.artifacts.ResolutionListener
import org.gradle.api.artifacts.ResolvedDependency
import org.gradle.api.internal.artifacts.repositories.resolver.ExternalResourceRepository

// Custom ResolutionListener to track dependency repository information
class DependencyResolutionListener implements ResolutionListener {
    def dependencyRepoMap = [:].withDefault { [] }

    @Override
    void beforeResolve(ResolvableDependencies resolvableDependencies) {
    }

    @Override
    void afterResolve(ResolvableDependencies resolvableDependencies) {
        resolvableDependencies.resolutionResult.allDependencies.each { dependency ->
            if (dependency.selected.id instanceof ModuleComponentIdentifier) {
                ModuleComponentIdentifier id = (ModuleComponentIdentifier) dependency.selected.id
                dependencyRepoMap[id] << resolvableDependencies.resolutionResult.root.id
            }
        }
    }
}

task resolveDependencies {
    doLast {
        def listener = new DependencyResolutionListener()
        configurations.all { conf ->
            conf.incoming.beforeResolve {
                listener.beforeResolve(it)
            }
            conf.incoming.afterResolve {
                listener.afterResolve(it)
            }
        }

        configurations.compileClasspath.resolve()

        def repoCounts = [
            'OpenSourceReleaseMaven': 0,
            'OpenSourceReleaseGradle': 0,
            'MavenCentral': 0,
            'Other': 0
        ]

        listener.dependencyRepoMap.each { key, value ->
            def repoUrl = value[0].repository?.url?.toString()
            if (repoUrl) {
                if (repoUrl.contains("open-source-release-maven")) {
                    repoCounts['OpenSourceReleaseMaven']++
                } else if (repoUrl.contains("open-source-release-gradle")) {
                    repoCounts['OpenSourceReleaseGradle']++
                } else if (repoUrl.contains("repo.maven.apache.org")) {
                    repoCounts['MavenCentral']++
                } else {
                    repoCounts['Other']++
                }
            } else {
                repoCounts['Other']++
            }
        }

        repoCounts.each { repo, count ->
            println "Dependencies downloaded from ${repo}: ${count}"
        }
    }
}

task buildWithDependencyReport {
    dependsOn 'build', 'resolveDependencies'
}



task countRepositoryJars {
  doLast {
    def releaseGradleCount = 0
    def releaseMavenCount = 0
    def repo1Count = 0

    configurations.compile.each { dependency ->
      switch (dependency.repository.url) {
        case 'release-gradle':
          releaseGradleCount++
          break
        case 'release-maven':
          releaseMavenCount++
          break
        case 'repo1':
          repo1Count++
          break
      }
    }

    logger.lifecycle "Downloaded JARs from repositories:"
    logger.lifecycle "  release-gradle: $releaseGradleCount"
    logger.lifecycle "  release-maven: $releaseMavenCount"
    logger.lifecycle "  repo1: $repo1Count"
  }
}


repositories {
    maven {
        url 'https://repo.maven.apache.org/maven2'
        name 'MavenCentral'
    }
    maven {
        url 'https://example.com/open-source-release-maven'
        name 'OpenSourceReleaseMaven'
    }
    maven {
        url 'https://example.com/open-source-release-gradle'
        name 'OpenSourceReleaseGradle'
    }
    // Add more repositories as needed
}


task resolveDependencies {
    doLast {
        def repoCounts = [
            'OpenSourceReleaseMaven': 0,
            'OpenSourceReleaseGradle': 0,
            'MavenCentral': 0,
            'Other': 0
        ]

        def repositoryNames = [
            'https://repo.maven.apache.org/maven2': 'MavenCentral',
            'https://example.com/open-source-release-maven': 'OpenSourceReleaseMaven',
            'https://example.com/open-source-release-gradle': 'OpenSourceReleaseGradle'
        ]

        configurations.compileClasspath.resolvedConfiguration.resolvedArtifacts.each { artifact ->
            def repoName = artifact.moduleVersion.id.group

            if (repositoryNames.containsKey(repoName)) {
                repoCounts[repositoryNames[repoName]]++
            } else {
                repoCounts['Other']++
            }
        }

        repoCounts.each { repo, count ->
            println "Dependencies downloaded from ${repo}: ${count}"
        }
    }
}

task buildWithDependencyReport {
    dependsOn 'build', 'resolveDependencies'
}


task resolveDependencies {
    doLast {
        def opensourcereleasemavenCount = 0
        def opensourcereleasegradleCount = 0
        def mavenCentralCount = 0
        def otherRepoCount = 0

        configurations.compileClasspath.incoming.resolutionResult.allComponents { component ->
            def componentId = component.id.toString()

            if (componentId.contains("open-source-release-maven")) {
                opensourcereleasemavenCount++
            } else if (componentId.contains("open-source-release-gradle")) {
                opensourcereleasegradleCount++
            } else if (componentId.contains("repo.maven.apache.org")) {
                mavenCentralCount++
            } else {
                otherRepoCount++
            }
        }

        println "Dependencies downloaded from open-source-release-maven: $opensourcereleasemavenCount"
        println "Dependencies downloaded from open-source-release-gradle: $opensourcereleasegradleCount"
        println "Dependencies downloaded from Maven Central: $mavenCentralCount"
        println "Dependencies downloaded from other repositories: $otherRepoCount"
    }
}

task buildWithDependencyReport {
    dependsOn 'build', 'resolveDependencies'
}


task resolveDependencies {
    doLast {
        def opensourcereleasemavenCount = 0
        def opensourcereleasegradleCount = 0
        def mavenCentralCount = 0
        def otherRepoCount = 0

        configurations.compileClasspath.incoming.resolutionResult.allComponents { component ->
            def repoUrl = component.id.toString()

            if (repoUrl.contains("open-source-release-maven")) {
                opensourcereleasemavenCount++
            } else if (repoUrl.contains("open-source-release-gradle")) {
                opensourcereleasegradleCount++
            } else if (repoUrl.contains("repo.maven.apache.org")) {
                mavenCentralCount++
            } else {
                otherRepoCount++
            }
        }

        println "Dependencies downloaded from open-source-release-maven: $opensourcereleasemavenCount"
        println "Dependencies downloaded from open-source-release-gradle: $opensourcereleasegradleCount"
        println "Dependencies downloaded from Maven Central: $mavenCentralCount"
        println "Dependencies downloaded from other repositories: $otherRepoCount"
    }
}

task buildWithDependencyReport {
    dependsOn 'build', 'resolveDependencies'
}


task resolveDependencies {
    doLast {
        def opensourcereleasemavenCount = 0
        def opensourcereleasegradleCount = 0
        def mavenCentralCount = 0
        def otherRepoCount = 0

        configurations.compileClasspath.resolvedConfiguration.resolvedArtifacts.each { artifact ->
            def moduleId = artifact.moduleVersion.id
            def repoUrl = artifact.file.toURI().toString()

            if (repoUrl.contains("open-source-release-maven")) {
                opensourcereleasemavenCount++
            } else if (repoUrl.contains("open-source-release-gradle")) {
                opensourcereleasegradleCount++
            } else if (repoUrl.contains("repo.maven.apache.org")) {
                mavenCentralCount++
            } else {
                otherRepoCount++
            }
        }

        println "Dependencies downloaded from open-source-release-maven: $opensourcereleasemavenCount"
        println "Dependencies downloaded from open-source-release-gradle: $opensourcereleasegradleCount"
        println "Dependencies downloaded from Maven Central: $mavenCentralCount"
        println "Dependencies downloaded from other repositories: $otherRepoCount"
    }
}

task buildWithDependencyReport {
    dependsOn resolveDependencies
}


plugins {
    id 'java'
}

group 'com.example'
version '1.0-SNAPSHOT'

repositories {
    maven {
        url "https://artifact-hub.fb.com/open-source-release-maven"
        name "opensourcereleasemaven"
    }
    maven {
        url "https://artifact-hub.fb.com/open-source-release-gradle"
        name "opensourcereleasegradle"
    }
    mavenCentral()
}

dependencies {
    implementation 'com.example:some-dependency:1.0.0'
    testImplementation 'junit:junit:4.12'
}

ext.repoCount = [opensourcereleasemaven: 0, opensourcereleasegradle: 0, mavenCentral: 0, other: 0]

configurations.all {
    resolutionStrategy {
        eachDependency { DependencyResolveDetails details ->
            def repoName = details.requested.module.toString()
            if (details.requested.group == "com.example") {
                if (repoName.contains("open-source-release-maven")) {
                    ext.repoCount.opensourcereleasemaven++
                } else if (repoName.contains("open-source-release-gradle")) {
                    ext.repoCount.opensourcereleasegradle++
                }
            } else if (repoName.contains("central")) {
                ext.repoCount.mavenCentral++
            } else {
                ext.repoCount.other++
            }
        }
    }
}

task resolveDependencies {
    doLast {
        println "Dependencies downloaded from open-source-release-maven: ${ext.repoCount.opensourcereleasemaven}"
        println "Dependencies downloaded from open-source-release-gradle: ${ext.repoCount.opensourcereleasegradle}"
        println "Dependencies downloaded from Maven Central: ${ext.repoCount.mavenCentral}"
        println "Dependencies downloaded from other repositories: ${ext.repoCount.other}"
    }
}

task buildWithDependencyReport {
    dependsOn resolveDependencies
}



plugins {
    id 'java'
}

group 'com.example'
version '1.0-SNAPSHOT'

repositories {
    maven {
        url "https://artifact-hub.fb.com/open-source-release-maven"
        name "opensourcereleasemaven"
    }
    maven {
        url "https://artifact-hub.fb.com/open-source-release-gradle"
        name "opensourcereleasegradle"
    }
    mavenCentral()
}

dependencies {
    implementation 'com.example:some-dependency:1.0.0'
    testImplementation 'junit:junit:4.12'
}

task resolveDependencies {
    doLast {
        def opensourcereleasemavenCount = 0
        def opensourcereleasegradleCount = 0
        def mavenCentralCount = 0
        def otherRepoCount = 0

        configurations.compileClasspath.resolvedConfiguration.resolvedArtifacts.each { artifact ->
            def repoUrl = artifact.file.absolutePath

            if (repoUrl.contains("open-source-release-maven")) {
                opensourcereleasemavenCount++
            } else if (repoUrl.contains("open-source-release-gradle")) {
                opensourcereleasegradleCount++
            } else if (repoUrl.contains("maven2")) {
                mavenCentralCount++
            } else {
                otherRepoCount++
            }
        }

        println "Dependencies downloaded from open-source-release-maven: $opensourcereleasemavenCount"
        println "Dependencies downloaded from open-source-release-gradle: $opensourcereleasegradleCount"
        println "Dependencies downloaded from Maven Central: $mavenCentralCount"
        println "Dependencies downloaded from other repositories: $otherRepoCount"
    }
}

task buildWithDependencyReport {
    dependsOn resolveDependencies
}



task resolveDependencies {
    doLast {
        def repoCounts = [:]

        configurations.compileClasspath.resolvedConfiguration.resolvedArtifacts.each { artifact ->
            def repoName = getRepositoryName(artifact.file.absolutePath)
            if (repoCounts.containsKey(repoName)) {
                repoCounts[repoName]++
            } else {
                repoCounts[repoName] = 1
            }
        }

        println "Dependency counts by repository:"
        repoCounts.each { repoName, count ->
            println "$repoName: $count"
        }
    }
}

def getRepositoryName(filePath) {
    if (filePath.contains("repo1.example.com")) {
        return "repo1"
    } else if (filePath.contains("repo2.example.com")) {
        return "repo2"
    } else {
        return "mavenCentral"
    }
}

task buildWithDependencyReport {
    dependsOn resolveDependencies
}


plugins {
    id 'java'
}

group 'com.example'
version '1.0-SNAPSHOT'

repositories {
    maven {
        url "https://repo1.example.com/maven2"
        name "repo1"
    }
    maven {
        url "https://repo2.example.com/maven2"
        name "repo2"
    }
    mavenCentral {
        name "mavenCentral"
    }
}

dependencies {
    implementation 'com.example:some-dependency:1.0.0'
    testImplementation 'junit:junit:4.12'
}

task dependencyReport {
    doLast {
        def repo1Count = 0
        def repo2Count = 0
        def mavenCentralCount = 0
        def otherRepoCount = 0

        configurations.compileClasspath.resolvedConfiguration.resolvedArtifacts.each { artifact ->
            def repoUrl = artifact.moduleVersion.id.repositoryName
            if (repoUrl == "repo1") {
                repo1Count++
            } else if (repoUrl == "repo2") {
                repo2Count++
            } else if (repoUrl == "mavenCentral") {
                mavenCentralCount++
            } else {
                otherRepoCount++
            }
        }

        println "Dependencies downloaded from repo1: $repo1Count"
        println "Dependencies downloaded from repo2: $repo2Count"
        println "Dependencies downloaded from Maven Central: $mavenCentralCount"
        println "Dependencies downloaded from other repositories: $otherRepoCount"
    }
}

tasks.register('buildWithDependencyReport') {
    dependsOn 'build'
    finalizedBy 'dependencyReport'
}


gradle buildWithDependencyReport


gradle dependencyInsight --dependency your-dependency-name --configuration compileClasspath --debug


for file in *.json; do
    sed -i 's/"ForceBuild": false/"ForceBuild": true/g' "$file"
done

kube_pod_info{node="node-name", job="kube-state-metrics"} offset 1h

(
  kube_pod_info{node="worker-node-1", job="kube-state-metrics"} offset 1h
  or
  kube_pod_info{node="worker-node-2", job="kube-state-metrics"} offset 1h
)

(
  kube_pod_info{node="worker-node-1", job="kube-state-metrics"} @ 2024-05-31T11:00:00Z
  or
  kube_pod_info{node="worker-node-2", job="kube-state-metrics"} @ 2024-05-31T11:00:00Z
)


kube_pod_status_phase * on(pod, namespace) group_left(node) (kube_pod_info * on(node) group_left(pod) kube_node_info)

label_join(kube_pod_info, "node", "node", "node") * on (node) group_left(pod) kube_node_info

kube_node_info


(
  max_over_time(kube_pod_status_ready{condition="true", pod=~".*ingress-gateway.*"}[5m]) == 0
)
OR
(
  max_over_time(kube_pod_status_phase{phase!="Running", pod=~".*ingress-gateway.*"}[5m]) == 1
)



(
  kube_pod_status_ready{condition="true", pod=~".*ingress-gateway.*"} == 0
)
OR
(
  kube_pod_status_phase{phase!="Running", pod=~".*ingress-gateway.*"}
)

(
  kube_pod_status_ready{condition="true", pod=~".*ingress-gateway.*"} == 0
  unless (kube_pod_status_ready{condition="true", pod=~".*ingress-gateway.*"} == 0)[5m]
)
OR
(
  kube_pod_status_phase{phase!="Running", pod=~".*ingress-gateway.*"}
  unless (kube_pod_status_phase{phase!="Running", pod=~".*ingress-gateway.*"})[5m]
)


Pod '{{ $labels.pod }}' in namespace '{{ $labels.namespace }}' is not in the desired state.
kube_pod_status_ready{condition="true", pod=~".*ingress-gateway.*"} == 0

pip install --extra-index-url https://username:password@your.jfrog.io/artifactory/api/pypi/your-repo-name/simple/ package-name


kube_pod_status_phase{phase="Running", namespace="your-namespace", pod=~".*ingress-gateway.*"} == 0


#!/bin/bash

# Configuration
NAMESPACE="your_namespace"
SLACK_WEBHOOK_URL="https://hooks.slack.com/services/your/slack/webhook"
CHECK_INTERVAL=300  # 5 minutes
CHECK_FILE="/tmp/ingress_pod_check"

# Function to send a Slack notification
send_slack_notification() {
    local pod_name=$1
    local pod_status=$2
    curl -X POST -H 'Content-type: application/json' --data "{
        \"text\": \"Pod $pod_name is not in Running status. Current status: $pod_status\"
    }" $SLACK_WEBHOOK_URL
}

# Function to check pod statuses
check_pods() {
    local non_running_pods=()
    while read -r line; do
        pod_name=$(echo $line | awk '{print $1}')
        pod_status=$(echo $line | awk '{print $3}')
        if [[ $pod_status != "Running" ]]; then
            non_running_pods+=("$pod_name:$pod_status")
        fi
    done <<< "$(kubectl get pods -n $NAMESPACE | grep ingress)"

    echo "${non_running_pods[@]}"
}

# Main loop
while true; do
    current_check=$(check_pods)
    previous_check=$(cat $CHECK_FILE 2>/dev/null || echo "")

    if [[ -n $current_check ]]; then
        for pod_info in $current_check; do
            pod_name=$(echo $pod_info | cut -d':' -f1)
            pod_status=$(echo $pod_info | cut -d':' -f2)

            if [[ $previous_check == *"$pod_name:$pod_status"* ]]; then
                send_slack_notification $pod_name $pod_status
            fi
        done
    fi

    echo $current_check > $CHECK_FILE
    sleep $CHECK_INTERVAL
done


sum(kube_pod_container_resource_requests_memory_bytes) by (node)


max_over_time(
  container_memory_usage_bytes{namespace="your_namespace", container!="POD", container!=""}[1h]
) * on(pod) group_left() (
  increase(kube_pod_container_status_restarts_total{namespace="your_namespace"}[1h]) > 0
)


#!/bin/bash

# Directory containing all your cloned projects
projects_dir="/path/to/your/projects"

# Loop through each project directory
for project in "$projects_dir"/*; do
  if [ -d "$project/.git" ]; then
    echo "Entering $project"
    cd "$project" || continue

    # Check the current branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)

    # Check for committed changes that haven't been pushed
    if git log origin/"$current_branch"..HEAD | grep -q "commit"; then
      echo "Pushing committed changes in $project on branch $current_branch"
      git push origin "$current_branch"
    else
      echo "No committed changes to push in $project on branch $current_branch"
    fi

    # Go back to the projects directory
    cd "$projects_dir" || exit
  else
    echo "$project is not a git repository"
  fi
done



#!/bin/bash

# Define the SSH user and hostname (replace with your details)
SSH_USER="your_username"
SSH_HOST="your_host"

# Define the directory to clone projects into (optional)
PROJECTS_DIR="projects"

# Read project names from a file (optional)
# Replace "projects.txt" with your file name
# uncomment the following line to use a file
# PROJECT_NAMES=( $(cat projects.txt) )

# Define project names directly in the script (alternative)
PROJECT_NAMES=("project1" "project2" "project3")

# Loop through project names
for project in "${PROJECT_NAMES[@]}"; do
  # Check if projects directory exists (if defined)
  if [[ ! -z "$PROJECTS_DIR" ]]; then
    mkdir -p "$PROJECTS_DIR"
  fi

  # Build the SSH URL for the project
  ssh_url="ssh://${SSH_USER}@${SSH_HOST}/${project}.git"

  # Clone the project using SSH
  git clone "$ssh_url" "${PROJECTS_DIR:-$project}"

  # Print success message
  echo "Cloned project: $project"
done

echo "All projects cloned!"

NAMESPACE=<your-namespace>

# Get a list of all deployments in the namespace
DEPLOYMENTS=$(kubectl get deployments -n $NAMESPACE -o=jsonpath='{.items[*].metadata.name}')

# Loop through each deployment and scale down to 0 replicas
for deployment in $DEPLOYMENTS; do
    kubectl scale deployment $deployment --replicas=0 -n $NAMESPACE
done

pip install --extra-index-url=https://username:password@example.com/repository/simple --trusted-host example.com <package_name>


kubectl get secret $(kubectl get serviceaccount <service-account-name> -o jsonpath='{.secrets[0].name}') -o jsonpath='{.data.token}' | base64 --decode

./gradlew dependencyInsight --configuration compileClasspath | grep -A 1 "Requested dependencies" | grep "from \['" | sed "s/.*from \['\(.*\)'\].*/\1/" | sort | uniq -c


