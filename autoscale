
import mysql.connector
from mysql.connector import Error
import argparse
import re

class NamespaceAllocator:
    def __init__(self, host, user, password, database):
        self.connection = None
        try:
            self.connection = mysql.connector.connect(
                host=host,
                user=user,
                password=password,
                database=database
            )
            if self.connection.is_connected():
                print("Connected to the database")
        except Error as e:
            print(f"Error connecting to MySQL: {e}")
            raise

    def priority_check(self,official_build, release_tag):
        if official_build == 'YES':
            # Check if release_tag matches the pattern 'XX.XX.X'
            if re.match(r'^\d{2}\.\d{1,2}\.\d{1,2}$', release_tag):
                priority = 'Critical'
            # Check if release_tag contains '23.4.0-ocngf-pre-dev'
            elif 'ocngf-pre-dev' in release_tag:
                priority = 'Medium'
            # Check if release_tag matches 'XX.XX.X-ocngf-X*' dynamically
            elif re.match(r'^\d{2}\.\d{1,2}\.\d{1,2}-ocngf-\d+.*', release_tag):
                priority = 'Low'
            else:
                priority = 'High'
        else:
            priority = 'Low'

        return priority

    def insert_or_update_status(self, nf_type, release_tag, ats_release_tag, is_csar, is_asm, is_tgz,
                                is_internal_ats, is_occ, is_pcf, is_converged, upg_rollback,
                                official_build):

        priority = self.priority_check(official_build,release_tag)
        try:
            cursor = self.connection.cursor()

            # Check if the row already exists
            cursor.execute("""
                SELECT s_no, status, namespace FROM namespace_status
                WHERE release_tag = %s
                AND ats_release_tag = %s
                AND is_csar = %s
                AND is_asm = %s
                AND is_tgz = %s
                AND is_internal_ats = %s
                AND is_occ = %s
                AND is_pcf = %s
                AND is_converged = %s
                AND upg_rollback = %s
            """, (release_tag, ats_release_tag, is_csar, is_asm, is_tgz, is_internal_ats, is_occ,
                  is_pcf, is_converged, upg_rollback))

            existing_row = cursor.fetchone()

            if existing_row:
                s_no, status, namespace = existing_row
                # If the row exists, check if the namespace is already allocated
                if status == 'ASSIGNED':
                    print(f"Namespace already allocated. Row s_no {s_no} has status 'ASSIGNED'.")
                    return
                else:
                    # Update the row to set status and lock if namespace is available
                    cursor.execute("""
                        UPDATE namespace_status
                        SET status = 'YET TO ASSIGN', allocation_lock = 'NO', date = CURRENT_TIMESTAMP
                        WHERE s_no = %s
                    """, (s_no,))
                    print(f"Updated row with s_no {s_no} to 'YET TO ASSIGN' and unlocked.")
            else:
                # If no row exists, insert a new row
                cursor.execute("""
                    INSERT INTO namespace_status (
                        nf_type, release_tag, ats_release_tag, namespace, is_csar, is_asm, is_tgz, is_internal_ats,
                        is_occ, is_pcf, is_converged, upg_rollback, offical_build, priority, status, allocation_lock
                    ) VALUES (
                        %s, %s, %s, '', %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, 'YET TO ASSIGN', 'NO'
                    )
                """, (nf_type, release_tag, ats_release_tag, is_csar, is_asm, is_tgz, is_internal_ats,
                      is_occ, is_pcf, is_converged, upg_rollback, official_build, priority))

                print("Inserted new row into namespace_status.")

            # Commit the changes
            self.connection.commit()

        except Error as e:
            print(f"Error during status insertion or update: {e}")
        finally:
            cursor.close()

    def allocate_namespace(self, nf_type, release_tag, ats_release_tag, is_csar, is_asm, is_tgz, is_internal_ats,
                           is_occ, is_pcf, is_converged, upg_rollback):
        try:
            cursor = self.connection.cursor(dictionary=True)

            # Step 1: Check if there is already an assigned namespace for this configuration
            cursor.execute("""
                SELECT namespace, status FROM namespace_status 
                WHERE release_tag = %s AND ats_release_tag = %s
                  AND is_csar = %s AND is_asm = %s 
                  AND is_tgz = %s AND is_internal_ats = %s 
                  AND is_occ = %s AND is_pcf = %s 
                  AND is_converged = %s AND upg_rollback = %s 
                  AND nf_type = %s
            """, (
                release_tag, ats_release_tag, is_csar, is_asm, is_tgz, is_internal_ats, is_occ, is_pcf, is_converged,
                upg_rollback, nf_type
            ))
            assigned_status = cursor.fetchone()

            if assigned_status and assigned_status['status'] == 'ASSIGNED':
                # If a namespace is already assigned, no need to allocate another one
                print(f"Namespace '{assigned_status['namespace']}' is already assigned for release_tag '{release_tag}'")
                return assigned_status['namespace']

            # Define the namespace prefix based on nf_type
            if nf_type == 'policy':
                namespace_prefix = 'o-devops-pol'
            elif nf_type == 'bsf':
                namespace_prefix = 'o-devops-bsf'
            else:
                print("Invalid nf_type")
                return None

            # Step 2: Find the first available namespace with `allocation_lock` = 'NO' that matches the prefix
            cursor.execute(f"""
                SELECT namespace FROM namespace 
                WHERE status = 'Available' 
                  AND allocation_lock = 'NO' 
                  AND namespace LIKE %s 
                LIMIT 1
            """, (f'{namespace_prefix}%',))
            available_namespace = cursor.fetchone()

            if available_namespace:
                namespace_name = available_namespace['namespace']

                # Print message indicating that the namespace is locked
                print(f"Locking namespace '{namespace_name}' for allocation")

                # Step 3: Set the `allocation_lock` = 'YES' for both tables to prevent concurrent access
                cursor.execute("UPDATE namespace SET allocation_lock = 'YES' WHERE namespace = %s", (namespace_name,))
                cursor.execute("""
                    UPDATE namespace_status
                    SET allocation_lock = 'YES'
                    WHERE release_tag = %s AND ats_release_tag = %s AND status = 'YET TO ASSIGN'
                      AND is_csar = %s AND is_asm = %s 
                      AND is_tgz = %s AND is_internal_ats = %s 
                      AND is_occ = %s AND is_pcf = %s 
                      AND is_converged = %s AND upg_rollback = %s 
                      AND nf_type = %s
                """, (
                    release_tag, ats_release_tag, is_csar, is_asm, is_tgz, is_internal_ats, is_occ, is_pcf, is_converged,
                    upg_rollback, nf_type
                ))

                self.connection.commit()

                # Step 4: Allocate the namespace and update the status
                cursor.execute("""
                    UPDATE namespace_status
                    SET namespace = %s, status = 'ASSIGNED', allocation_lock = 'NO'
                    WHERE release_tag = %s AND ats_release_tag = %s
                      AND is_csar = %s AND is_asm = %s 
                      AND is_tgz = %s AND is_internal_ats = %s 
                      AND is_occ = %s AND is_pcf = %s 
                      AND is_converged = %s AND upg_rollback = %s
                      AND nf_type = %s
                """, (
                    namespace_name, release_tag, ats_release_tag, is_csar, is_asm, is_tgz, is_internal_ats, is_occ, is_pcf,
                    is_converged, upg_rollback, nf_type
                ))

                cursor.execute("UPDATE namespace SET status = 'In-Use', allocation_lock = 'NO' WHERE namespace = %s",
                               (namespace_name,))

                # Commit the changes to the database
                self.connection.commit()

                print(f"Namespace '{namespace_name}' has been allocated to release_tag '{release_tag}'")

                # Print updated row details from namespace_status
                return namespace_name

            else:
                print("No available namespaces or they are locked.")
                return None

        except Error as e:
            print(f"Error during namespace allocation: {e}")
        finally:
            cursor.close()

    def delete_namespace(self, namespace_name):
        try:
            cursor = self.connection.cursor()

            # Delete the row from namespace_status where namespace matches
            cursor.execute("""
                DELETE FROM namespace_status
                WHERE namespace = %s
            """, (namespace_name,))

            # Update the status of the namespace in the namespace table to 'Available'
            cursor.execute("""
                UPDATE namespace
                SET status = 'Available', allocation_lock = 'NO'
                WHERE namespace = %s
            """, (namespace_name,))

            # Commit the changes
            self.connection.commit()

            print(f"Deleted namespace '{namespace_name}' from namespace_status and updated status to 'Available'.")

        except Error as e:
            print(f"Error during namespace deletion: {e}")
        finally:
            cursor.close()

    def close_connection(self):
        if self.connection.is_connected():
            self.connection.close()
            print("MySQL connection closed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Manage namespace allocation and status.")

    parser.add_argument('action', choices=['insert_or_update', 'allocate', 'delete'],
                        help="Action to perform: insert_or_update, allocate, or delete")
    parser.add_argument('--nf_type', help="Namespace type (policy or bsf)")
    parser.add_argument('--release_tag', help="Release tag")
    parser.add_argument('--ats_release_tag', help="ATS release tag")
    parser.add_argument('--is_csar', help="Is CSAR (YES or NO)")
    parser.add_argument('--is_asm', help="Is ASM (YES or NO)")
    parser.add_argument('--is_tgz', help="Is TGZ (YES or NO)")
    parser.add_argument('--is_internal_ats', help="Is internal ATS (YES or NO)")
    parser.add_argument('--is_occ', help="Is OCC (YES or NO)")
    parser.add_argument('--is_pcf', help="Is PCF (YES or NO)")
    parser.add_argument('--is_converged', help="Is converged (YES or NO)")
    parser.add_argument('--upg_rollback', help="Upgrade rollback (YES or NO)")
    parser.add_argument('--official_build', help="Official build (YES or NO)")
    parser.add_argument('--priority', help="Priority (Critical, High, Medium, Low)")
    parser.add_argument('--namespace', help="Namespace to delete")

    args = parser.parse_args()

    # Replace with your actual database connection details
    db_host = "localhost"
    db_user = "root"
    db_password = "root"
    db_name = "namespace_management"

    allocator = NamespaceAllocator(db_host, db_user, db_password, db_name)

    if args.action == 'insert_or_update':
        allocator.insert_or_update_status(
            nf_type=args.nf_type,
            release_tag=args.release_tag,
            ats_release_tag=args.ats_release_tag,
            is_csar=args.is_csar,
            is_asm=args.is_asm,
            is_tgz=args.is_tgz,
            is_internal_ats=args.is_internal_ats,
            is_occ=args.is_occ,
            is_pcf=args.is_pcf,
            is_converged=args.is_converged,
            upg_rollback=args.upg_rollback,
            official_build=args.official_build
            # priority=args.priority
        )
    elif args.action == 'allocate':
        allocator.allocate_namespace(
            nf_type=args.nf_type,
            release_tag=args.release_tag,
            ats_release_tag=args.ats_release_tag,
            is_csar=args.is_csar,
            is_asm=args.is_asm,
            is_tgz=args.is_tgz,
            is_internal_ats=args.is_internal_ats,
            is_occ=args.is_occ,
            is_pcf=args.is_pcf,
            is_converged=args.is_converged,
            upg_rollback=args.upg_rollback
        )
    elif args.action == 'delete':
        if args.namespace:
            allocator.delete_namespace(args.namespace)
        else:
            print("Please provide a namespace to delete using --namespace.")

    allocator.close_connection()
