Hi Team,

We’ve noticed that the PR template (as mentioned here) is now supported. However, I don’t see this option available in our project. Could someone help identify what might be missing?

Thanks in advance!


git log --pretty=format:"%h %an %ar %s" --numstat | awk '
NF == 3 { insert+=$1; delete+=$2; next }
NF != 3 { print insert, delete, $0; insert=0; delete=0 }
' | sort -k1,1n -k2,2n | tail -n 10



git rev-list --objects --all | \
git cat-file --batch-check='%(objectname) %(objecttype) %(size) %(rest)' | \
sort -k3 -n -r | head -n 10


du -sh .git



To configure JFrog with authentication for npm, you can follow these steps:

Steps to Configure JFrog with npm Authentication:
1. Set Up Authentication with JFrog
Log in to your JFrog Artifactory instance.
Navigate to your User Profile (top-right corner).
Scroll down to Authentication Settings and generate an API Key or retrieve your Access Token.
2. Configure .npmrc for JFrog
You need to configure your local .npmrc file to use your JFrog registry and authenticate with your credentials.

Use the following command to add your JFrog repository as a registry:

bash
Copy
Edit
npm config set registry https://<JFROG_DOMAIN>/artifactory/api/npm/<REPOSITORY_NAME>/
Replace:

<JFROG_DOMAIN> with your JFrog domain (e.g., mycompany.jfrog.io).
<REPOSITORY_NAME> with your npm repository name in JFrog (e.g., npm-local).
Add your authentication token or username/password:

bash
Copy
Edit
npm config set _auth <BASE64_ENCODED_USERNAME:PASSWORD>
OR

bash
Copy
Edit
npm config set _authToken <YOUR_ACCESS_TOKEN>
For _auth, encode your username and password in Base64:
bash
Copy
Edit
echo -n "username:password" | base64
For _authToken, replace <YOUR_ACCESS_TOKEN> with your JFrog access token or API key.
Set your email (optional but sometimes required):

bash
Copy
Edit
npm config set email <YOUR_EMAIL>
3. Verify the Configuration
Check your .npmrc configuration:
bash
Copy
Edit
npm config list
You should see the registry and authentication values configured.
4. Test the Connection
Run the following command to ensure it works:
bash
Copy
Edit
npm whoami
If successful, it will return the username associated with your JFrog credentials.
Example .npmrc Configuration:
If you prefer to edit your .npmrc manually, it should look like this:

ini
Copy
Edit
registry=https://<JFROG_DOMAIN>/artifactory/api/npm/<REPOSITORY_NAME>/
_auth=<BASE64_ENCODED_USERNAME:PASSWORD>
email=<YOUR_EMAIL>
Notes:
Ensure you replace placeholders with actual values specific to your JFrog instance.
If using npm in a CI/CD pipeline, use environment variables for sensitive data like _auth or _authToken.
Let me know if you need help with anything specific!



kubectl get pod -A -o custom-columns='NAMESPACE:.metadata.namespace,CPU_REQUESTS:.spec.containers[*].resources.requests.cpu' | awk '
BEGIN { print "Namespace\tTotal_CPU_Requests" }
NR > 1 {
  cpu_sum[$1] += ($2 ~ "m" ? $2 + 0 : $2 * 1000)
}
END {
  for (namespace in cpu_sum) {
    print namespace, "\t", cpu_sum[namespace] "m"
  }
}'



Danish, can you test the parallel execution notification using the CI/CD setup?
Additionally, the namespaces are not in the o-devops format, so the auto-cleanup script could not detect them. As a result, it has been running for over 3 days.

Yesterday, on the o-devops-pol16 namespace, the upgrade and rollback for the 15th NB was deployed. During testing, the job runner got stuck. I attempted to re-run the job, but it failed with a 400 BAD REQUEST error.

To address this, I deleted the record from the UI. However, since a .lock file existed, the namespace wasn’t deleted. This resulted in the namespace being marked as available in the database.

This behavior highlights a bug in the auto-namespace deployment script: while the script correctly identifies the .lock file and skips cleanup, the UI does not perform this check, allowing the namespace to be incorrectly marked as available. I will log a bug to address this issue.


What should happen if the required Diam-Sim version is unavailable? Should it fall back to the most recent previous version?

Previously, we utilized the VM.Standard.E3.Flex shape, which worked seamlessly with ATS. However, due to host unavailability issues with the E3 shape, we transitioned to the X7 shape as recommended by SWATGO.

sum(rate(container_cpu_cfs_throttled_seconds_total{container!=""}[5m])) by (pod) > 0


### Auto Namespace Management for Parallel Execution/Deployment

To support parallel execution and deployment, the following enhancements have been made:

---

#### **Database Modifications**
Two new columns are added to the MySQL database to manage parallel deployment configurations:
1. **`parallel_execution`**: Accepts values `Yes` or `No` to indicate if the deployment supports parallel execution.
2. **`parallel_count`**: Holds integer values (`1`, `2`, `3`, etc.) to uniquely identify rows for each parallel deployment instance.

---

#### **Pipeline Parameters**
The **one-click-play pipeline** now includes the following parameters:

1. **`PARALLEL_PKG_TYPE`**: Defines the deployment type. Possible values are:
   - `tgz`: For TGZ package deployments.
   - `csar`: For CSAR package deployments.
   - `asm`: For ASM package deployments.
   - `external`: For external deployments.

2. **Namespace Parameters for Parallel Deployment**:
   - **CSAR Parallel Deployment**:
     - `CSAR_ASM_POLICY_NAMESPACE_1`
     - `CSAR_ASM_POLICY_NAMESPACE_2`
     - `CSAR_ASM_POLICY_NAMESPACE_3`
   - **ASM Parallel Deployment**:
     - `ASM_POLICY_NAMESPACE_1`
     - `ASM_POLICY_NAMESPACE_2`
     - `ASM_POLICY_NAMESPACE_3`
   - **TGZ Parallel Deployment**:
     - `TGZ_POLICY_NAMESPACE_1`
     - `TGZ_POLICY_NAMESPACE_2`
     - `TGZ_POLICY_NAMESPACE_3`
   - **External Parallel Deployment**:
     - `POLICY_NAMESPACE_1`
     - `POLICY_NAMESPACE_2`
     - `POLICY_NAMESPACE_3`

---

#### **Pipeline Behavior**
1. **Triggering Parallel Deployment**:
   - In the `export_downstream_job`, for each parallel deployment, three rows are inserted into the database with identical parameter values.
   - Each row has a unique `parallel_count` value (`1`, `2`, or `3`).

2. **Namespace Assignment**:
   - During deployment, the pipeline fetches the appropriate row for each `parallel_count`.
   - The namespace is assigned sequentially based on the `parallel_count` value.

---

#### **Other Features**
All other features and functionalities remain consistent with the existing deployment process.
