def update_namespace_in_env(namespace_name: str, parallel_count=None):
    """
    Updates the NAMESPACE variable in the environment file.
    """
    env_file = config.ENV_FILE
    try:
        lines = read_lines(env_file)
        with open(env_file, 'w') as file:
            updated = False
            
            if os.getenv("PARALLEL_EXECUTION") == 'true' and parallel_count is not None:
                # Update for parallel execution: NAMESPACE_1, NAMESPACE_2, NAMESPACE_3
                file.write(f"NAMESPACE_{parallel_count}={namespace_name}\n")
                updated = True
            else:
                # For non-parallel execution, or if no parallel_count is provided
                for line in lines:
                    if line.startswith("NAMESPACE="):
                        file.write(f"NAMESPACE={namespace_name}\n")
                        updated = True
                    else:
                        file.write(line)

                if not updated:
                    file.write(f"NAMESPACE={namespace_name}\n")

        logging.info(f"NAMESPACE{('_' + str(parallel_count) if parallel_count else '')} updated to '{namespace_name}' in {env_file}")

    except IOError as e:
        logging.error(f"Error updating NAMESPACE in {env_file}: {e}")



# Proceed to auto-assign for the current parallel_count
namespace_name = find_and_lock_available_namespace(cursor, kwargs['nf_type'])
if namespace_name:
    update_status_and_lock(self.db_connection.connection, cursor, namespace_name, pipeline_url, kwargs)
    update_namespace_in_env(namespace_name)
    logging.info(f"Namespace {namespace_name} successfully locked and assigned.")
    # Instead of returning, continue to the next parallel_count
    continue  
else:
    logging.warning(f"No available namespaces found for parallel_count = {parallel_count}.")



def allocate_namespace(self, **kwargs) -> Optional[str]:
    """
    Allocates a namespace for the given parameters.
    """
    try:
        with self.db_connection.get_cursor() as cursor:
            pipeline_url = self._get_env_variable("CI_PIPELINE_URL")

            # Handle upgrade case if play_id is provided
            if kwargs.get('play_id'):
                if self._handle_upgrade(cursor, kwargs):
                    return None  # Exit if the upgrade was handled

            # Check for parallel execution mode
            is_parallel_execution = (
                os.getenv('CI_PROJECT_TITLE') == 'one-click-integration' and
                os.getenv('PARALLEL_EXECUTION') == 'true'
            )

            parallel_counts = [1, 2, 3] if is_parallel_execution else [None]

            for parallel_count in parallel_counts:
                if parallel_count:
                    kwargs['parallel_count'] = parallel_count
                    logging.info(f"Processing for parallel_count = {parallel_count}")
                else:
                    logging.info("Processing for non-parallel execution")

                # Fetch existing statuses for the current parallel_count
                existing_statuses = get_existing_status(cursor, kwargs)

                if not existing_statuses:
                    logging.info(f"No existing statuses found for parallel_count = {parallel_count}")
                    continue  # Skip to the next parallel_count

                logging.info(f"Handling {len(existing_statuses)} existing statuses for parallel_count = {parallel_count}")

                # Iterate over each existing status
                for status in existing_statuses:
                    namespace_name = self._handle_assigned_status(cursor, status, pipeline_url, kwargs)
                    if namespace_name:
                        logging.info(f"Namespace {namespace_name} successfully assigned for status: {status}")
                        return namespace_name  # Exit on successful assignment

                    # Fetch and log CPU requests for the current status
                    total_cpu_requests = self._fetch_and_log_cpu_requests(cursor, [status], kwargs)
                    if total_cpu_requests is None:
                        logging.warning(f"No CPU requests available for status: {status}")
                        continue  # Skip to the next status

                # Proceed to auto-assign for the current parallel_count
                namespace_name = find_and_lock_available_namespace(cursor, kwargs['nf_type'])
                if namespace_name:
                    update_status_and_lock(self.db_connection.connection, cursor, namespace_name, pipeline_url, kwargs)
                    update_namespace_in_env(namespace_name)
                    logging.info(f"Namespace {namespace_name} successfully locked and assigned.")
                    return namespace_name  # Exit on successful locking

            logging.warning("No available namespaces or assignments after processing all parallel counts.")
            return None

    except Error as e:
        logging.error(f"Error during namespace allocation: {e}")
        raise NamespaceAllocationError("Namespace allocation failed.")
