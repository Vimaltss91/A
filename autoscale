Subject: Service Mesh - Multi Config Support for Envoy Filter in 25.1.200

Hi Rajiv,

We wanted to check with you regarding the service mesh configuration for custom values (configKey and configValue) in the Envoy filter.

Currently, the Policy ASM supports only a single key-value pair for custom configuration. However, starting from the UDR team's 25.1.200 release, support for multiple key-value configurations has been added.

Do we have any specific customer requirements that need this multi-config support in 25.1.200? Based on the need and priority, we can plan to include it in 25.1.200 or consider it for a later release.

Please find below the reference details for the ASM config chart related to 25.1.200.

Thanks,
[Your Name]




Hi Benson,

We are seeing multiple issues with node packages that are not identified by the deployment/ATS, but they break the UI page. On checking, we found that the job packages are built using npm pack and the files are pushed, but not all packages work correctly with just npm pack.

For example, if the source code is in TypeScript, it needs to be built first using npm run build (which generates the module), and only then should npm pack be run. Since BFS is not done for most of these packages, we need to identify and remove such problematic packages (or possibly rebuild all packages created for this PI).

Can we please update the open source pipeline to first run npm run build and skip file validation (similar to how it's done for Java)?

Example: The yaml package's dist folder module is missing — this happened because BFS was not done. You can refer to yaml from the public repo for comparison.










Title:
Upload failures to Artifactory from IAD runner farm (Podracer jobs)

Description:
Hi team,

We are experiencing a recurring issue when attempting to upload large files from the Podracer runner to Artifactory. This issue appears more frequently when running jobs on the IAD runner farm (#3227, TM_i97t8, OKE IAD Runner Farm) compared to the PHX runner farm.

While there have been some successful jobs on the IAD runner farm, failures are noticeably more common.

Could you please check if there is any known issue with the IAD runner farm? Are uploads from this farm typically successful, or are there any current limitations we should be aware of?

Sample Job Links:
✅ PHX Success:

PHX Job 1

PHX Job 2

❌ IAD Failure:

IAD Job 1

IAD Job 2

IAD Job 3




Multiple packages were pushed to the dev repository, but the error messages don’t clearly indicate which package is corrupted. Additional debugging is required to identify the specific corrupted package


sudo dnf groupinstall -y "Server with GUI"
sudo dnf install -y epel-release
sudo dnf install -y xrdp tigervnc-server xfce4-session firefox

# Enable XRDP service
sudo systemctl enable xrdp
sudo systemctl start xrdp

# Allow xrdp in firewall
sudo firewall-cmd --add-port=3389/tcp --permanent
sudo firewall-cmd --reload

# Set XFCE as default session for all users
echo "startxfce4" > ~/.Xclients
chmod +x ~/.Xclients

# Optional: set for system default (not just current user)
sudo bash -c 'echo PREFERRED=/usr/bin/startxfce4 > /etc/sysconfig/desktop'

# Reboot to apply everything
sudo reboot




# Install Firefox browser
sudo dnf install -y firefox

# Install Python and pip
sudo dnf install -y python3 python3-pip

# Install Selenium
pip3 install selenium

# Download latest GeckoDriver (Firefox WebDriver)
GECKO_VERSION=$(curl -s https://api.github.com/repos/mozilla/geckodriver/releases/latest | grep tag_name | cut -d '"' -f4)
wget "https://github.com/mozilla/geckodriver/releases/download/$GECKO_VERSION/geckodriver-$GECKO_VERSION-linux64.tar.gz"

# Extract and move to path
tar -xzf geckodriver-$GECKO_VERSION-linux64.tar.gz
sudo mv geckodriver /usr/local/bin/
sudo chmod +x /usr/local/bin/geckodriver
rm -f geckodriver-$GECKO_VERSION-linux64.tar.gz


-----------COde -------
from selenium import webdriver
from selenium.webdriver.firefox.options import Options
from selenium.webdriver.common.by import By
import time

# ⚠️ GUI mode — do NOT enable headless
options = Options()
# Do not add headless here
# options.add_argument('--headless')

# Optional: set screen size
options.add_argument("--width=1920")
options.add_argument("--height=1080")

# Launch browser
driver = webdriver.Firefox(options=options)

# Open website
driver.get("https://www.w3schools.com/howto/howto_html_file_upload_button.asp")
time.sleep(2)

# Simulate file upload (optional example)
upload = driver.find_element(By.XPATH, '//input[@type="file"]')
upload.send_keys("/home/youruser/sample.txt")  # Replace with actual path

# Screenshot (optional)
driver.save_screenshot("firefox_gui_screenshot.png")
print("✅ GUI test completed. Screenshot saved.")

driver.quit()

-----------------------




Since some packages have already been pushed to the dev repository, the CM service pipeline is currently broken due to the corrupted packages. I’ve already informed Benson via email that this is blocking our testing and the promotion to the release repository

Okay, I’ll check and coordinate with Bharat. Since we've already pushed the packages to the dev repository and some of them are corrupted, we're still unable to identify the root cause. As a result, it's blocking our testing and further promotion to the release repository

I have sent an email to Benson, mentioning that many Node packages are corrupted and require debugging and manual removal. This is a time-consuming and repetitive process for each package, so I’ve stated that the Node packages are currently blocked from being moved to the release repository


Hi Benson,

Some of the Node packages were previously pushed in a corrupted state. We have rectified a few of them last week, purged the affected versions, and successfully moved the clean packages to the release repository.

However, the remaining packages have only been pushed to the development repository, and several of them are still corrupted. This is currently blocking us from moving them to the release repository.

Additionally, the corrupted packages have to be manually removed from Artifactory each time, which is not scalable.




all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details ->
        def constraintBundle = ocpmLibs.bundles.ocpmConstraints.get()

        constraintBundle.each {
            def String constraintEntry = it
            def (constraintGroup, constraintModule, constraintVersion) = constraintEntry.tokenize(":")
            
            if (details.requested.group == constraintGroup && details.requested.name == constraintModule) {
                details.useVersion constraintVersion
                details.because 'Constraint defined in 3rd party catalog'
            }
        }

        // ✅ Manual Jetty constraint (outside the bundle)
        if (details.requested.group == "org.eclipse.jetty" && details.requested.name == "jetty-server") {
            details.useVersion "12.0.21"
            details.because "Jetty version override (manual)"
        }
    }
}





# Update system
sudo yum update -y

# Install required tools and Python
sudo yum install -y wget unzip curl python3 java-11-openjdk xorg-x11-server-Xvfb \
    alsa-lib libXScrnSaver gtk3 nss libXcomposite libXcursor libXdamage \
    libXrandr libXtst libgbm

# Install pip
sudo python3 -m ensurepip --upgrade


cat <<EOF | sudo tee /etc/yum.repos.d/google-chrome.repo
[google-chrome]
name=google-chrome
baseurl=https://dl.google.com/linux/chrome/rpm/stable/x86_64
enabled=1
gpgcheck=1
gpgkey=https://dl.google.com/linux/linux_signing_key.pub
EOF

sudo yum install -y google-chrome-stable


# Get Chrome version
CHROME_VERSION=$(google-chrome --version | grep -oP '[0-9.]+' | head -1 | cut -d. -f1)

# Get compatible ChromeDriver version
CHROMEDRIVER_VERSION=$(curl -s "https://chromedriver.storage.googleapis.com/LATEST_RELEASE_${CHROME_VERSION}")

# Download and install
wget https://chromedriver.storage.googleapis.com/${CHROMEDRIVER_VERSION}/chromedriver_linux64.zip
unzip chromedriver_linux64.zip
sudo mv chromedriver /usr/local/bin/
chmod +x /usr/local/bin/chromedriver


pip3 install selenium


from selenium import webdriver
from selenium.webdriver.chrome.options import Options

options = Options()
options.add_argument('--headless')
options.add_argument('--no-sandbox')
options.add_argument('--disable-dev-shm-usage')

driver = webdriver.Chrome(options=options)

driver.get("https://example.com")
print("Page Title:", driver.title)

driver.quit()


python3 selenium_test.py

python3 selenium_test.py



sudo yum install -y xorg-x11-server-Xvfb


# Check if xvfb-run exists
which xvfb-run

# If not, create a basic version:
sudo tee /usr/local/bin/xvfb-run > /dev/null <<'EOF'
#!/bin/bash
XVFB_WHD=${XVFB_WHD:-1280x720x24}
XVFB_DISPLAY=${XVFB_DISPLAY:-:99}

Xvfb $XVFB_DISPLAY -screen 0 $XVFB_WHD &
XVFB_PID=$!

export DISPLAY=$XVFB_DISPLAY
"$@"

kill $XVFB_PID
EOF

sudo chmod +x /usr/local/bin/xvfb-run

xvfb-run python3 selenium_test.py



from selenium import webdriver
from selenium.webdriver.chrome.options import Options

options = Options()
# NOT headless — will need Xvfb
# options.add_argument('--headless')  # <-- comment this out
options.add_argument('--no-sandbox')
options.add_argument('--disable-dev-shm-usage')

driver = webdriver.Chrome(options=options)
driver.set_window_size(1920, 1080)
driver.get("https://example.com")

# Take screenshot
driver.save_screenshot("screenshot.png")
print("Screenshot saved.")

driver.quit()



from selenium import webdriver
from selenium.webdriver.chrome.options import Options
import tempfile
import time

# ✅ Create a temporary user-data-dir to avoid profile lock/session errors
temp_profile = tempfile.mkdtemp()

options = Options()
# ⚠️ DO NOT use headless mode if you need GUI interaction like file picker
# options.add_argument('--headless')  # Uncomment ONLY if running headless
options.add_argument('--no-sandbox')
options.add_argument('--disable-dev-shm-usage')
options.add_argument(f'--user-data-dir={temp_profile}')

# ✅ Launch Chrome
driver = webdriver.Chrome(options=options)

# Optional: set window size if needed
driver.set_window_size(1920, 1080)

# ✅ Navigate to test page
driver.get("https://example.com")

# Wait for page to load
time.sleep(2)

# ✅ Take screenshot
driver.save_screenshot("screenshot.png")
print("✅ Screenshot saved at screenshot.png")

# ✅ Clean up
driver.quit()



