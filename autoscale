
(
  kube_pod_status_ready{condition="true", pod=~".*ingress-gateway.*"} == 0
)
OR
(
  kube_pod_status_phase{phase!="Running", pod=~".*ingress-gateway.*"}
)

(
  kube_pod_status_ready{condition="true", pod=~".*ingress-gateway.*"} == 0
  unless (kube_pod_status_ready{condition="true", pod=~".*ingress-gateway.*"} == 0)[5m]
)
OR
(
  kube_pod_status_phase{phase!="Running", pod=~".*ingress-gateway.*"}
  unless (kube_pod_status_phase{phase!="Running", pod=~".*ingress-gateway.*"})[5m]
)


Pod '{{ $labels.pod }}' in namespace '{{ $labels.namespace }}' is not in the desired state.
kube_pod_status_ready{condition="true", pod=~".*ingress-gateway.*"} == 0

pip install --extra-index-url https://username:password@your.jfrog.io/artifactory/api/pypi/your-repo-name/simple/ package-name


kube_pod_status_phase{phase="Running", namespace="your-namespace", pod=~".*ingress-gateway.*"} == 0


#!/bin/bash

# Configuration
NAMESPACE="your_namespace"
SLACK_WEBHOOK_URL="https://hooks.slack.com/services/your/slack/webhook"
CHECK_INTERVAL=300  # 5 minutes
CHECK_FILE="/tmp/ingress_pod_check"

# Function to send a Slack notification
send_slack_notification() {
    local pod_name=$1
    local pod_status=$2
    curl -X POST -H 'Content-type: application/json' --data "{
        \"text\": \"Pod $pod_name is not in Running status. Current status: $pod_status\"
    }" $SLACK_WEBHOOK_URL
}

# Function to check pod statuses
check_pods() {
    local non_running_pods=()
    while read -r line; do
        pod_name=$(echo $line | awk '{print $1}')
        pod_status=$(echo $line | awk '{print $3}')
        if [[ $pod_status != "Running" ]]; then
            non_running_pods+=("$pod_name:$pod_status")
        fi
    done <<< "$(kubectl get pods -n $NAMESPACE | grep ingress)"

    echo "${non_running_pods[@]}"
}

# Main loop
while true; do
    current_check=$(check_pods)
    previous_check=$(cat $CHECK_FILE 2>/dev/null || echo "")

    if [[ -n $current_check ]]; then
        for pod_info in $current_check; do
            pod_name=$(echo $pod_info | cut -d':' -f1)
            pod_status=$(echo $pod_info | cut -d':' -f2)

            if [[ $previous_check == *"$pod_name:$pod_status"* ]]; then
                send_slack_notification $pod_name $pod_status
            fi
        done
    fi

    echo $current_check > $CHECK_FILE
    sleep $CHECK_INTERVAL
done


sum(kube_pod_container_resource_requests_memory_bytes) by (node)


max_over_time(
  container_memory_usage_bytes{namespace="your_namespace", container!="POD", container!=""}[1h]
) * on(pod) group_left() (
  increase(kube_pod_container_status_restarts_total{namespace="your_namespace"}[1h]) > 0
)


#!/bin/bash

# Directory containing all your cloned projects
projects_dir="/path/to/your/projects"

# Loop through each project directory
for project in "$projects_dir"/*; do
  if [ -d "$project/.git" ]; then
    echo "Entering $project"
    cd "$project" || continue

    # Check the current branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)

    # Check for committed changes that haven't been pushed
    if git log origin/"$current_branch"..HEAD | grep -q "commit"; then
      echo "Pushing committed changes in $project on branch $current_branch"
      git push origin "$current_branch"
    else
      echo "No committed changes to push in $project on branch $current_branch"
    fi

    # Go back to the projects directory
    cd "$projects_dir" || exit
  else
    echo "$project is not a git repository"
  fi
done



#!/bin/bash

# Define the SSH user and hostname (replace with your details)
SSH_USER="your_username"
SSH_HOST="your_host"

# Define the directory to clone projects into (optional)
PROJECTS_DIR="projects"

# Read project names from a file (optional)
# Replace "projects.txt" with your file name
# uncomment the following line to use a file
# PROJECT_NAMES=( $(cat projects.txt) )

# Define project names directly in the script (alternative)
PROJECT_NAMES=("project1" "project2" "project3")

# Loop through project names
for project in "${PROJECT_NAMES[@]}"; do
  # Check if projects directory exists (if defined)
  if [[ ! -z "$PROJECTS_DIR" ]]; then
    mkdir -p "$PROJECTS_DIR"
  fi

  # Build the SSH URL for the project
  ssh_url="ssh://${SSH_USER}@${SSH_HOST}/${project}.git"

  # Clone the project using SSH
  git clone "$ssh_url" "${PROJECTS_DIR:-$project}"

  # Print success message
  echo "Cloned project: $project"
done

echo "All projects cloned!"

NAMESPACE=<your-namespace>

# Get a list of all deployments in the namespace
DEPLOYMENTS=$(kubectl get deployments -n $NAMESPACE -o=jsonpath='{.items[*].metadata.name}')

# Loop through each deployment and scale down to 0 replicas
for deployment in $DEPLOYMENTS; do
    kubectl scale deployment $deployment --replicas=0 -n $NAMESPACE
done

pip install --extra-index-url=https://username:password@example.com/repository/simple --trusted-host example.com <package_name>


kubectl get secret $(kubectl get serviceaccount <service-account-name> -o jsonpath='{.secrets[0].name}') -o jsonpath='{.data.token}' | base64 --decode

./gradlew dependencyInsight --configuration compileClasspath | grep -A 1 "Requested dependencies" | grep "from \['" | sed "s/.*from \['\(.*\)'\].*/\1/" | sort | uniq -c


