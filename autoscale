import requests

# GitLab API credentials and project details
GITLAB_API_TOKEN = "your_gitlab_api_token"
PROJECT_ID = "your_project_id"
GITLAB_URL = "https://gitlab.com"
SPECIFIC_SCHEDULE_ID = "your_schedule_id"  # Replace with the ID of the specific schedule

# Headers for GitLab API requests
headers = {
    "Private-Token": GITLAB_API_TOKEN
}

def get_specific_schedule():
    url = f"{GITLAB_URL}/api/v4/projects/{PROJECT_ID}/pipeline_schedules/{SPECIFIC_SCHEDULE_ID}"
    response = requests.get(url, headers=headers)
    response.raise_for_status()
    return response.json()

def generate_curl_command(schedule):
    ref = schedule['ref']
    variables = {var['key']: var['value'] for var in schedule.get('variables', [])}

    # Base curl command
    curl_command = f"curl -X POST {GITLAB_URL}/api/v4/projects/{PROJECT_ID}/trigger/pipeline "
    curl_command += f"-F token={GITLAB_API_TOKEN} -F ref={ref}"

    # Add each variable as a parameter in the curl command
    for key, value in variables.items():
        curl_command += f" -F {key}={value}"

    print("Generated curl command:")
    print(curl_command)

def main():
    schedule = get_specific_schedule()
    generate_curl_command(schedule)

if __name__ == "__main__":
    main()



def handle_job_status_change(cursor, job_name, job_id, previous_status, current_status):
    """Handle transitions between job statuses and trigger external scripts."""
    # Determine if an update is necessary (status change to canceled/failed or resumed from them)
    if current_status in ["canceled", "failed"] or (previous_status in ["canceled", "failed"] and current_status in ["running", "pending"]):
        action = "transitioned to" if current_status in ["canceled", "failed"] else "resumed from"
        logging.info(f"{job_name} - {job_id} {action} {previous_status} to {current_status}. Calling DB to update the status...")
        
        # Start transaction and update build status
        cursor.execute("START TRANSACTION;")
        sql_query = generate_sql_params(CURRENT_PIPELINE_ID, job_name)
        logging.info(f"SQL Query condition is {sql_query} and current status is {current_status}")
        update_build_status(cursor, current_status, sql_query)
        cursor.execute("COMMIT;")



GRADLE_OPTS="-Xmx4096m -XX:NativeMemoryTracking=summary"
GRADLE_OPTS="-Xmx4096m -XX:MaxMetaspaceSize=512m"


job_name:
  script:
    - export GRADLE_OPTS="-Xmx2048m -XX:MaxPermSize=512m"
    - gradle build


gradle --no-daemon clean --info --debug --stacktrace -Dorg.gradle.internal.http.debug=true -Dorg.gradle.internal.http.wire=true

script:
  - while true; do curl -I https://repo.maven.apache.org && sleep 5; done &
  - gradle --no-daemon clean build --info --debug --stacktrace


gradle --no-daemon clean build --info --debug --stacktrace \
    -Dorg.gradle.internal.http.connectionTimeout=60000 \
    -Dorg.gradle.internal.http.socketTimeout=60000
script:
  - for i in {1..3}; do gradle --no-daemon clean build --info --debug --stacktrace && break || sleep 10; done


The line db_connection = DatabaseConnection() in main.py does not actually open the database connection. It just creates an instance of the DatabaseConnection class. The connection itself is only opened when you explicitly call db_connection.connect() or implicitly when get_cursor() calls self.connect() if the connection isnâ€™t already open.
