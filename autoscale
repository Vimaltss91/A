def get_existing_status(cursor, kwargs: dict) -> list:
    """Retrieves the existing status for a namespace from the database with optional parallel execution."""
    query = """
        SELECT s_no, status, namespace, priority, official_build, release_tag, ats_release_tag
        FROM namespace_status
        WHERE nf_type = %s AND release_tag = %s AND ats_release_tag = %s AND is_csar = %s
        AND is_asm = %s AND is_tgz = %s AND is_internal_ats = %s AND is_occ = %s
        AND is_pcf = %s AND is_converged = %s AND is_pcrf = %s AND upg_phase = %s AND play_id = %s 
        AND tls_version = %s AND upg_rollback = %s AND official_build = %s AND custom_message = %s
    """
    params_base = [
        kwargs['nf_type'], kwargs['release_tag'], kwargs['ats_release_tag'], kwargs['is_csar'], kwargs['is_asm'],
        kwargs['is_tgz'], kwargs['is_internal_ats'], kwargs['is_occ'], kwargs['is_pcf'],
        kwargs['is_converged'], kwargs['is_pcrf'], kwargs['upg_phase'], kwargs['play_id'], kwargs['tls_version'],
        kwargs['upg_rollback'], kwargs['official_build'], kwargs['custom_message']
    ]

    results = []

    # Check for parallel execution condition
    if os.getenv('CI_PROJECT_TITLE') == 'one-click-integration' and os.getenv("PARALLEL_EXECUTION") == 'true':
        query += " AND parallel_count = %s"
        # Execute the query for parallel_count 1, 2, and 3
        for parallel_count in [1, 2, 3]:
            params = params_base + [parallel_count]
            execute_query(cursor, query, params)
            result = cursor.fetchall()  # Fetch all rows for this iteration
            if result:
                results.extend(result)  # Add results to the list if any are found
    else:
        # Execute the query without parallel_count condition
        execute_query(cursor, query, params_base)
        results = cursor.fetchall()  # Fetch all rows for this query

    return results
