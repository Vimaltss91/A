import json

def update_json_with_text_data(text_file_path, json_file_path):
    try:
        # Read the contents of the text file
        with open(text_file_path, 'r') as text_file:
            text_data = text_file.read()

        # Load the existing JSON data
        with open(json_file_path, 'r') as json_file:
            json_data = json.load(json_file)

        # Convert text data to a dictionary
        text_dict = {}
        pairs = text_data.strip().split('\n')
        for pair in pairs:
            key, value = pair.split('=')
            text_dict[key.strip()] = value.strip()

        # Find the index of the dictionary in "data" list with matching job_id
        index_to_update = -1
        for idx, data_entry in enumerate(json_data["data"]):
            if data_entry.get("job_id") == text_dict.get("job_id"):
                index_to_update = idx
                break

        # Update the existing data with the new values for the matched job_id
        if index_to_update != -1:
            json_data["data"][index_to_update].update(text_dict)

        # Save the updated JSON data back to the file
        with open(json_file_path, 'w') as json_file:
            json.dump(json_data, json_file, indent=4)

        print("JSON file updated successfully.")
    except FileNotFoundError:
        print("File not found. Please check the file paths.")
    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    text_file_path = "path/to/your_text_file.txt"
    json_file_path = "path/to/your_json_file.json"
    update_json_with_text_data(text_file_path, json_file_path)

import os

def helm_check_version():
    cne_version = os.environ.get("CNE_VERSION", "")
    if "1.8" in cne_version:
        helm = "helm3"
    else:
        helm = "helm"
    return helm

helm = helm_check_version()
print(helm)


import subprocess
import os

def get_helm_list(namespace):
    try:
        helm_list_cmd = f"{helm} list -n {namespace}"
        output = subprocess.check_output(helm_list_cmd, shell=True, text=True)
        return output
    except subprocess.CalledProcessError as e:
        print(f"Error: {e}")
        return None

def get_release_tag(namespace):
    helm_output = get_helm_list(namespace)
    if helm_output:
        lines = helm_output.strip().split('\n')
        for line in lines:
            if namespace in line and 'csf' in line and 'ats' not in line and 'dns' not in line:
                parts = line.split()
                tag = parts[8].replace("ocbsf-", "")
                return tag
    return None

def main():
    CSF_SUITE = os.environ.get("CSF_SUITE", "")
    NAMESPACE = os.environ.get("NAMESPACE", "")
    helm = "helm"

    if CSF_SUITE == "CSF":
        RELEASE_TAG = get_release_tag(NAMESPACE)
        if RELEASE_TAG is None:
            RELEASE_TAG = "CSF_RELEASE_TAG"
    
    print(RELEASE_TAG)

if __name__ == "__main__":
    main()


def find_total_feature_with_previous_line(file_path):
    with open(file_path, "r") as file:
        previous_line = None
        for line in file:
            if "Total-Feature" in line and previous_line and "Final Result" in previous_line:
                return line.strip()  # Return the line containing "Total-Feature"
            previous_line = line  # Store the current line for the next iteration
    return None  # If not found, return None

file_path = "data.log"  # Replace with the actual file path

result_line = find_total_feature_with_previous_line(file_path)
if result_line:
    print(result_line)
else:
    print("Total-Feature with preceding 'Final Result' not found.")
In this Python code, the find_total_feature_with_previous_line function reads the file line by line. It checks for the presence of "Total-Feature" in the current line and also verifies if the previous line contains "Final Result." If both conditions are met, the function returns the line containing "Total-Feature" (stripped of leading/trailing spaces). Otherwise, it continues to the next line until the end of the file.

Replace "data.log" with the actual path to the file containing the log data. The variable result_line will contain the line with "Total-Feature" if it's found, and you will get the desired output. If the condition is not met, it will print "Total-Feature with preceding 'Final Result' not found."






